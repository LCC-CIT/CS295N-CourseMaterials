<!DOCTYPE html><html>  <head>    <meta http-equiv="content-type" content="text/html; charset=UTF-8">    <title>Week 7, Day 1, EF + dB</title>    <style type="text/css">body {  font-family: "Arial", "Helvetica", "sans-serif";}footer {	font-size:smaller;	font-variant:small-caps;}#week07 {  background-color: #f8ff2e;}code {  display:block;  font-size: larger;  background-color: lightgoldenrodyellow;  max-height:450px;  width:85%;  overflow:scroll;  margin:0.5%;}      ul {   margin:0.5%;}      h2, h3, h4 {   display:inline;}      .exercise {  background-color: #c6ffe2;}</style> </head>  <body> <b>CS295N Web Development 1: ASP.NET </b><br>    <b> </b>    <header>      <div>Brian Bird</div>      <h1> <i><b>Entity Framework and Database </b></i></h1>      <h1><i><b> </b></i></h1>      <b>Where we are </b>      <table style="width: 807px; height: 127px;" border="1">        <tbody>          <tr>            <td id="week01">1. Intro to MVC</td>            <td id="week06">6. Unit Testing and Repositories</td>          </tr>          <tr>            <td id="week02">2. Domain Modeling</td>            <td id="week07">7. Entity Framework (EF)</td>          </tr>          <tr>            <td id="week03">3. C# Review / Advanced C# for MVC</td>            <td id="week08">8. More on EF / LINQ</td>          </tr>          <tr>            <td id="week04">4. Razor Views and Tag Helpers</td>            <td id="week09">9. Model Binding / Validation</td>          </tr>          <tr>            <td id="week05">5. Azure, Web Dev Tools and Debugging</td>            <td id="week10">10. Configuration / URL routing</td>          </tr>        </tbody>      </table>      <h2><b><b>Contents</b></b></h2>      <div>        <ul>          <b>            <li><a href="#topic1">Introduction</a></li>            <li><a href="#topic2">Review </a></li>            <li><a href="#topic3a">Object Relational Mapping and Entity                Framework Core</a></li>            <li style="margin-left: 40px;"><a href="#topic3">Adding Entity                Framework to a Web App</a></li>            <li style="margin-left: 40px;"><a href="#topic4">Creating and                Applying a Migration</a></li>          </b><b>            <li style="margin-left: 40px;"><a href="#topic5">Viewing Your                Database</a></li>            <li><a href="#topic5a">Running Unit Tests</a></li>            <li><a href="#topic6">Example</a></li>            <li><a href="#topic7">Reference</a></li>          </b>        </ul>      </div>    </header>    <br>    <hr><br>    <section>      <article id="topic1">        <h2>Introduction</h2>        <ul>          <li>Announcement:</li>        </ul>        <ul>          <ul>            <li>TAO: <a href="http://www.techoregon.org/events/experience-oregon-tech-1"                target="_blank">                Experience Oregon Tech</a></li>          </ul>          <li>Review lab due dates on Moodle</li>          <li>Discuss questions about the previous lab</li>        </ul>      </article>      <br>      <hr>      <article id="topic2">        <h2>Review </h2>        <h3>Repository Pattern and Dependency Injection</h3>        <p>Last week we discussed these topics and went through an example using          my BookInfo web site. Here's a review, based on Ch. 18 of the          textbook.</p>        <ul>          <li><b>IRepository (the interface) </b><br>            The author of the textbook did a few things differently than I did.            <br>            Do you think there are advantages to doing them this way?<br>            <ul>              <li>The collection property has type <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1?view=netcore-2.1"                  target="_blank">IEnumerable
                  </a>â€” which means that you can iterate over the collection <br>                This allows a collection of Product objects to be implemented                using any class that implements IEnumerable:<br>                <code>IEnumerable&lt;Products&gt; { get; } </code></li>              <li>Individual Product objects in the collection are made                available through an <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/indexers/index"                  target="_blank">indexer</a>                :<br>                <code>Product this[string name] { get; }</code></li>            </ul>          </li>          <li> <b>MemoryRepository</b><br>            Again the author did things a bit differently than I did. What are            the pros and cons of each approach?<br>            <ul>              <li>Uses a Dictionary to hold the collection of Product objects in                memory. (It could have used a List, or Array or other collection                class as long as it can return an IEnumerable collection.)</li>              <li>Code uses lambda expressions to implement:                <ul>                  <li>A property:<br>                    <code>public IEnumerable&lt;Product&gt; Products =&gt;                      products.Values;</code> </li>                  <li>An indexer:<br>                    <code>public Product this[string name] =&gt; products[name];</code>                  </li>                  <li>A method:<br>                    <code>public void DeleteProduct(Product product) =&gt;                      products.Remove(product.Name);</code></li>                </ul>              </li>            </ul>          </li>          <li><b>Instantiating a repository object</b><br>            A repository need to be instantiated in any controller that access            data.<br>            The author has a good discussion of loosely coupled vs. tightly            coupled components with examples of both.<br>            <ul>              <li>A <span style="color: #c70000;">not-so-good way</span>                (tightly coupled)<br>                <code>public class HomeController : Controller {<br>                  &nbsp;&nbsp; public ViewResult Index() =&gt; View(<b>new                    MemoryRepository()</b>.Products);</code></li>              <li>A <span style="color: #009600;">better way</span> (loosely                coupled)<br>                The author shows you several DIY ways to do this, but ultimately                we'll want to <u>use the built-in ASP.NET Core Dependency                  Injection</u><br>                <code></code><b> </b></li>              <b> </b>            </ul>            <b> </b>            <ul>            </ul>            <b> </b></li>          <b> </b>          <li><b>ASP.NET Core Dependency Injection </b>            <ul>              <li>Preparing the controller<br>                The author did this the same way I did:<br>                <code>public class HomeController : Controller {<br>                  &nbsp; private IRepository repository;<br>                  &nbsp; public HomeController(IRepository repo) =&gt;                  repository = repo;</code> </li>              <li>Configuring the Startup class<br>                <code>public class Startup {<br>                  &nbsp; public void ConfigureServices(IServiceCollection                  services) {<br>                  &nbsp;&nbsp;&nbsp; <b>services.AddTransient&lt;IRepository,                    MemoryRepository&gt;();</b><br>                  &nbsp;&nbsp;&nbsp; services.AddMvc();</code> </li>            </ul>          </li>          <li><b>Advanced DI techniques that we <span style="color: #bf0000;">aren't
                using</span>: </b>            <ul>              <li>Mocking framework<br>                In his unit tests, the author uses a mocking framework to create                the mock, or "fake", repository. <u>We won't do it this way</u>.                We created our fake repository in our own code. Here is the code                the author used to add a mock repository to his unit test:<br>                <code>[Fact]<br>                  public void ControllerTest() {<br>                  &nbsp; // Arrange<br>                  &nbsp; var data = new[] { new Product { Name = "Test", Price =                  100 } };<br>                  &nbsp; var mock = new Mock&lt;IRepository&gt;();<br>                  &nbsp; mock.SetupGet(m =&gt; m.Products).Returns(data);<br>                  &nbsp; HomeController controller = new                  HomeController(mock.Object);</code></li>              <li>Type Broker </li>            </ul>          </li>        </ul>      </article>      <br>      <hr><br>      <article id="topic3a">        <h2>Object Relational Mapping and Entity Framework Core </h2>        <p>One of the main functions of Entity Framework is to do <a href="https://en.wikipedia.org/wiki/Object-relational_mapping"            target="_blank">Object
            Relational Mapping</a>. The purpose of an Object Relational Mapper          (ORM) is to serve as a bridge between the world of our object oriented          code and the world of the relational database. An ORM maps a domain          model to a database schema and allows developers to just focus on          writing OO code while the ORM takes care of database operations.</p>        <p>EF is not the only ORM option for .NET Core developers. Other options          include:</p>        <ul>          <li><a href="https://github.com/nhibernate/nhibernate-core" target="_blank">NHibernate</a>&nbsp;
            -- the most mature and popular alternative to EF for .NET developers</li>          <li><a href="https://github.com/StackExchange/Dapper" target="_blank">Dapper</a></li>          <li><a href="https://github.com/schotime/NPoco/wiki" target="_blank"><span                style="color: #0000ee;">NPoco</span></a></li>          <li><span style=" color: #0000ee;"><a href="https://linq2db.github.io"                target="_blank">LINQ
                to Db</a> </span></li>        </ul>      </article>      <br>      The current version, 2.1, of Entity Framework Core has <a href="https://docs.microsoft.com/en-us/ef/core/providers/"        target="_blank">database
        providers</a> that support the following database types:<br>      <ul>        <li>SQL Server (including LocalDB)</li>        <li>Microsoft Access</li>        <li>Oracle</li>        <li>SQLite</li>        <li>PostgreSQL</li>        <li>MySQL</li>        <li>Db2</li>        <li>MyCAT</li>        <li>Firebird</li>      </ul>      <hr> <br>      <article id="topic3">        <h2>Adding Entity Framework to a Web App</h2>        <br>        <ul>          <li> There are two major approaches to managing databases and models            in EF:</li>        </ul>        <ul>          <ul>            <li>Code first (Model first) -- we are using this approach</li>          </ul>          <ul>            <li>Database first </li>          </ul>        </ul>        <ul>          <li> In order to use Entity Framework in your web app you need to add            the things that follow to your project.</li>        </ul>        <br>        <h3>Models</h3>        <br>        Ideally, we would like our models to be designed solely with object        oriented design in mind--&nbsp; without thinking about databases. But in        reality we do need to consider how Entity Framework will generate a        database schema based on our models. Two main things to consider are:        <ul>          <li><b>Defining primary keys</b><br>            We need to identify a field in the model that EF can map to a            primary key. We have two alternatives:            <ul>              <li>Add the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.keyattribute?view=netcore-2.1"                  target="_blank">[key]</a>                data annotation attribute to a property:<br>                Would this provide a unique key?<br>                <code>public class Book<br>                  {<br>                  &nbsp;&nbsp; [key]<br>                  &nbsp;&nbsp; public string Title { get; set; }</code></li>              <span style="font-family: monospace;">-- </span><span style="font-family: Helvetica,Arial,sans-serif;">or</span><span                style="font-family: monospace;">                --</span><br>              <li>Add an ID property:<br>                By convention, any property name ending in ID will be mapped to                a primary key<br>                This is guaranteed to be a unique key<br>                <code>public class Book<br>                  {<br>                  &nbsp;&nbsp; public int BookID { get; set; }<br>                  &nbsp;&nbsp; public string Title { get; set; }</code></li>            </ul>          </li>          <li><b>Avoiding many-to-many relationships</b>            <ul>              <li>The current version of EF, version 2.1, <a href="https://docs.microsoft.com/en-us/ef/core/modeling/relationships#many-to-many"                  target="_blank">doesn't
                  support many-to-many relationships</a></li>              <li>Do the current GoodBookNook have any many-to-many                relationships?</li>            </ul>          </li>        </ul>        <h3>DbContext Class</h3>        <ul>          <li>This class provides an entry point for your application to access            Entity Framework Core which provides access to the database.</li>          <li>You define your own database context class that inherits from            DbContext <br>            <code>public class ApplicationDbContext : DbContext<br>              {<br>              &nbsp;&nbsp;&nbsp; public ApplicationDbContext(<br>              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              DbContextOptions&lt;ApplicationDbContext&gt; options) :              base(options) { }<br>              &nbsp;&nbsp;&nbsp; public DbSet&lt;Book&gt; Books { get; set; }<br>              &nbsp;&nbsp;&nbsp; public DbSet&lt;Author&gt; Authors { get; set;              }<br>              &nbsp;&nbsp;&nbsp; public DbSet&lt;User&gt; Users { get; set; }<br>              }</code></li>        </ul>        <h3>Connection String</h3>        <ul>          <li>A connection string specifies the location and name of the            database and provides configuration settings.</li>          <li>Connection strings are stored in appsettings.json. <br>            <code>"Data": {<br>              &nbsp;&nbsp; "GoodBookNook": {<br>              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ConnectionString":              "Server=(localdb)\\MSSQLLocalDB;Database=GoodBookNook;<br>              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              Trusted_Connection=True;MultipleActiveResultSets=true"<br>              &nbsp;&nbsp; }<br>              }</code> </li>        </ul>        <h3>Startup Class</h3>        <br>        In the <span style="font-style: italic;">ConfigureServices</span>        method, add a service for DbContext. <br>        <ul>          <li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.entityframeworkservicecollectionextensions.adddbcontext?view=efcore-2.1"              target="_blank">AddDbContext</a>            will read the connection string and configure your DbContext to            connect to your database. </li>          <li>This service also performs <i>dependency injection</i> to inject            your DbContext object into any of your classes that the framework            instantiates that have your DbContext class as a parameter in the            constructor.</li>          <li>The options argument specifies that this is a Microsoft SQL Server            database.</li>          <li>Example:<br>            <code>services.AddDbContext&lt;ApplicationDbContext&gt;(options              =&gt; options.UseSqlServer(</code><code>&nbsp;&nbsp;              Configuration["Data:GoodBookNook:ConnectionString"]));<appidentitydbcontext></appidentitydbcontext></code>          </li>        </ul>        <h3> Your Repositories </h3>        <br>        You probably already have repositories that store data in memory for        testing (I call these "fake" real repositories)<br>        You need to modify these to use your DbContext to connect to the        database instead of using some kind of Collection (like a List) to store        data in memory.<br>        <ul>          <li>Modify the constructor to accept your DbContext object. This            object will be supplied by the framework using DI.</li>          <li>Modify each of the methods on in the repository to use the            DbContext object instead of the in-memory collection</li>          <li>Example:<br>            <code>public&nbsp; class BookRepository : IBookRepository {<br>              &nbsp;&nbsp; private AppDbContext context;<br>              <br>              &nbsp;&nbsp; public&nbsp; List&lt;Book&gt; Books { get {<br>              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return              context.Books.Include("Authors").Include("Reviews").ToList(); } <br>              &nbsp;&nbsp; }<br>              <br>              &nbsp;&nbsp; public BookRepository(AppDbContext appDbContext) {<br>              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context = appDbContext;<br>              &nbsp;&nbsp; }<br>              <br>              &nbsp;&nbsp; public&nbsp; void AddBook(Book book) {<br>              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context.Books.Add(book);<br>              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context.SaveChanges();<br>              &nbsp;&nbsp; }</code></li>        </ul>        <br>        <h3>Program Class</h3>        <br>        <br>        <h4>Disable Scope Validation </h4>        <ul>          <li>Meaning of Scope:<br>            The AddTransient methods have options for controlling the service            lifetime. One option is <span style="font-style:            italic;">scoped</span>            lifetime, which means services are created once per request. </li>        </ul>        <ul>          <li>Scope Validation:<br>            When the app is running in the Development environment, the default            service provider performs checks to verify that: </li>        </ul>        <ul>          <ul>            <li>Scoped services aren't directly or indirectly resolved from the              root service provider.</li>          </ul>          <ul>            <li>Scoped services aren't directly or indirectly injected into              singletons.<span style="text-decoration: underline;"></span></li>            <li><span style="text-decoration: underline;">Scope validation must                be disabled or an exception will be thrown when trying to create                the database</span> (EF won't be able to create the tables). </li>          </ul>          <li>Example:<br>            <code>public static IWebHostBuilder CreateWebHostBuilder(string[]              args) =&gt;<br>              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              WebHost.CreateDefaultBuilder(args)<br>              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              .UseStartup&lt;Startup&gt;()<br>              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              .UseDefaultServiceProvider(options =&gt;<br>              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              options.ValidateScopes = false);<startup></startup></code></li>        </ul>        <h4>BuildWebHost method</h4>        <i>You don't need to do anything here. This is for information only.</i>        <ul>          <li>The BuildWebHost method uses static methods defined by the WebHost            class to configure ASP.NET Core.</li>          <li>The UseStartup method is called to identify the class that will            provide application-specific configuration; the convention is to            name the class "Startup". </li>          <li>The Build method processes all the configuration settings and            creates an object that implements the IWebHost interface, which is            returned to the Main method, which calls Run to start handling HTTP            request. </li>          <li>References:            <ul>              <li>Freeman 2017, Ch. 14 "Configuring Applications"</li>              <li><a href="https://wildermuth.com/2017/07/06/Program-cs-in-ASP-NET-Core-2-0"                  target="_blank">Program.cs
                  in ASP.NET Core 2.0</a></li>            </ul>          </li>        </ul>      </article>      <hr> <br>      <article id="topic4">        <h2>Creating and Applying a Migration</h2>        <br>        <i>Migrations</i> are a means of solving the problem of how to update        the database when the models change. After changing any model, you will        need to "add a migration" which puts code in the Migrations folder of        the project that will be used by EF to update the Db schema as well as        migrate the data from the old schema to the new schema.<br>        <br>        <h3>Creating a Migration</h3>        <p>Use the CLI command:</p>        <p> <span style="font-family: Courier New,Courier,monospace;">dotnet ef            migrations add <i>Initial</i></span> </p>        <ul>          <li>No database will be created</li>          <li>A file will be added to the Migrations folder</li>          <li>The DbContextModelSnapshot file will be created or updated </li>        </ul>        <p>Running this command will cause the following to take place: </p>        <ol>          <li>Build the .NET Core assembly for the project in the folder where            you ran the command</li>          <li>Find DbContext classes</li>          <li>Find IDesignTimeDbContextFactory implementations</li>          <li>Find application database service provider</li>          <li>Find BuildWebHost method</li>          <li>Use environment 'Development'.</li>          <li>Use application service provider from BuildWebHost method on            'Program'</li>          <li>Connect to LocalDB using the user's Windows credentials<br>            <span style="font-style: italic;">--------- </span><span style="font-style: italic;">the
              first 8 operations are the same for adding a migration and appling              a migration ---------</span> </li>          <li>Create new migration file in the Migrations folder</li>          <li>Update the sanpshot file in the Migrations folder </li>        </ol>        <h3>Applying a Migration</h3>        <br>        <br>        Use the CLI command:        <p> <span style="font-family: Courier New,Courier,monospace;"> dotnet            ef database update</span></p>        <ul>        </ul>        <ul>          <li>If the database hasn't previously been created, this command will            also create the database.</li>          <li>Running this command will cause the same operations as the first            eight above to take place, plus: </li>        </ul>      </article>      <article id="topic4">        <ul>          <ul>            <li>Create a database if one does not exist </li>          </ul>          <ul>            <li>Execute SQL statements to apply the migrations if they are not              already applied</li>          </ul>          <li>Reference: <a href="https://docs.microsoft.com/en-us/ef/core/miscellaneous/cli/dotnet"              target="_blank">EF
              Core .NET Command-line Tools</a></li>        </ul>        <p>Note: if you want to drop the database so you can run update again,          use this CLI command:</p>        <p><span style="font-family: Courier New,Courier,monospace;">dotnet ef            database drop </span></p>        <ul>        </ul>      </article>      <br>      <hr><br>      <article topic="topic5">        <h2>Viewing Your Database</h2>        <br>        After EF has created a database, you can use SQL Server Object Explorer        in Visual Studio to view it.<br>        <ul>          <li>The server name will be: <span style="font-style:              italic;">(localdb)\MSSQLLocalDB</span></li>          <li>Connection should be through Windows Authentication with a user            name that looks like: <span style="font-style:              italic;">DESKTOP-SGC2610\Brian</span></li>        </ul>        <p><span style="font-style: italic;">Main things of interest: </span></p>        <ul>          <li>Tables</li>          <li>Columns</li>          <li>Data </li>        </ul>      </article>      <br>      <hr> <br>      <article id="topic5a">        <h2>Running Unit Tests </h2>        <br>        Adding EF should not have broken any of your unit tests. But it's good        practice to run the tests before pushing our code to the central        repository (on GitHub). </article>      <br>      <hr> <br>      <article id="topic6">        <h2>Example</h2>        <br>        <a href="https://github.com/LCC-CIT/CS295N-Bookinfo-Core-21/tree/EF" target="_blank">BookInfo,
          branch EF</a> </article>      <br>      <hr>      <article id="topic8">        <h2>References</h2>        <ul>          <li>Textbook - <span style="font-style: italic;">Pro ASP.NET Core MVC              2.0</span>, Adam Freeman, Apress, 2017.<br>            Ch. 8 "Sports Store, a Real Application", section titled,<br>            "Preparing a Database" (page 208), with sub-sections:            <ul>              <li>Installing the Entity Framework Core Tools Package </li>              <li>Creating the Database Classes </li>              <li>Creating the Repository Class </li>              <li>Defining the Connection String </li>              <li>Configuring the Application                <ul>                  <li>&nbsp;"Disabling Scope Verification"</li>                </ul>              </li>              <li>Creating the Database Migration&nbsp;</li>              <li>Creating the Seed Data </li>            </ul>          </li>          <li>Microsoft Docs: <a href="https://docs.microsoft.com/en-us/ef/core/"              target="_blank">Entity
              Framework Core</a></li>          <li>Microsoft Tutorial: <a href="https://docs.microsoft.com/en-us/aspnet/core/data/ef-mvc/"              target="_blank">Get
              started with ASP.NET Core MVC and Entity Framework Core using              Visual Studio</a></li>          <li>.NET Core API Reference: <a href="https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations?view=netcore-2.1"              target="_blank">System.ComponentModel.DataAnnotations
              Namespace</a></li>          <li>Microsoft Reference: <a href="https://docs.microsoft.com/en-us/ef/core/miscellaneous/cli/dotnet"              target="_blank">Entity
              Framework Core tools reference - .NET CLI</a></li>          <li>Microsoft tutorial: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection"              target="_blank">Dependency
              Injection in ASP.NET Core</a></li>        </ul>        <ul>        </ul>      </article>    </section>    <footer>      <hr style="width: 100%; height: 2px;"><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img          alt="Creative Commons License"          style="border-width:0"          src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a><br>      <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">ASP.NET        Core MVC Lecture Notes</span> by <a xmlns:cc="http://creativecommons.org/ns#"        href="https://birdsbits.blog"        property="cc:attributionName"        rel="cc:attributionURL">Brian
        Bird</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
        Commons Attribution-ShareAlike 4.0 International License</a>. </footer>    <hr>  </body></html>